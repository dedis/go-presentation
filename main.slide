# Go for your PhD
The language, its tools, best practices and cool toys
6 May 2021

Gaurav Narula

Noémien Kocher

Pierluca Borsò


## Talk outline

- Why is Go awesome? <!-- language properties -->
- The tools you're going to love <!-- fmt, vet, race detection, testing tools ... -->
- How to screw up (or not) <!-- bad practices and better ones -->
- Understanding and debugging <!-- using GoLand --> 
- Getting that extra performance kick <!-- profiling, workers, directio, ... -->
- Monitoring and measurements <!-- prometheus -->

.image assets/gophers/GOPHER_ADADEMY.png _ 250

## Next slide

And some more content

## Best practices

- Organize your source
- Handle errors
- Use custom types

## Organize your sources

- (**bad** code + **good** architecture) `>` (**good** code + **bad** architecture)
- break down your project into independent modules
- iterative process (that's an investment, but worth it)
- prevents import cycles
- 🏆 🏆 🏆 3 wins: readability / testability / maintainability

```
bypros
│   mod.go
│
└───browse         <- standalone functionality
│   │   mod.go     <- interface
│   │
│   └───paginate   <- an implementation
│       │   mod.go
│   
└───storage
    │   ...
```

## Handle errors

.image assets/free-gophers-pack/illustrations/png/2.png 250 _

.html pages/errors.html

## If your code doesn't look like this ... 🟠

.html pages/errors-handling.html

## Fail fast

.html pages/errors-fail-fast.html

## Embed functionalities with struct

.html pages/embed-struct.html

## File Optimisations

- The suggestions here don't apply for normal scenarios
- As a rule of thumb, prefer to use io.Reader, io.Writer interfaces - *os.File implements them
- However, there might be scenarios where you want to avoid them

## Recap: Disk IO and Virtual Memory

- Traditional read/write APIs use the read/write syscalls

- Read syscall:
  - Requests the kernel to read the file at an offset
  - If the page is available in the kernel's page cache, the kernel copies it to user space buffer
  - Otherwise we have a page fault, kernel reads the page into page cache and then copies it into user space buffer

- Write syscall:
  - Requests the kerel to copy the data into page cache.
  - Kernel schedules the sync to disk
  - User can block on sync using fsync

## Recap: Disk IO and Virtual Memory
.image assets/io/traditional.svg 700 _

## Memory Mapping

- mmap allows mapping of an entire file in memory
- Process' virtual address space maps directly to page cache
  - No copying of buffers
- Does not imply you need RAM == size of file
  - Because pages are loaded on demand
- Can also map regions of the file in memory
  - Caveat: offset must be page aligned (usually 4K but varies with the system)

## Memory Mapping

- Kernel does have to do more book keeping behind the scenes
- Might be worth it if you're dealing with a large file and want to avoid allocations again and again
- A page fault in mmap doesn't preempt a Go routine
  - you'd underutilise your CPU in that case because an OS thread would be [blocked](https://valyala.medium.com/mmap-in-go-considered-harmful-d92a25cb161d)
- Watchout for concurrent write operations to an mmaped file. `ftruncate` for instance doesn't play well with mmap
  - Have a look at [Bryan Cantrill's experience with tail](https://youtu.be/vm1GJMp0QN4?t=2463)

## Memory Mapping

.html pages/mmap-file-modify.html

## Memory Mapping

.html pages/mmap-fixed-size-data-read.html

## Direct IO

- As the name implies, it allows bypassing the page cache completely!
- Data is copied directly to/from the userspace/disk
- Writes/Reads must be block aligned - usually 512B.
- Useful if you want to control caching on the application level
- Allows finer control over scheduling IO - remember writes just mark a page dirty?
  - the Go runtime and the kernel would still be scheduling your thread

## Direct IO

.html pages/directio-file-copy.html