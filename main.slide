# Go for your PhD
The language, its tools, best practices and cool toys
6 May 2021

Gaurav Narula

No√©mien Kocher

Pierluca Bors√≤


## Talk outline

- Why is Go awesome? <!-- language properties -->
- The tools you're going to love <!-- fmt, vet, race detection, testing tools ... -->
- How to screw up (or not) <!-- bad practices and better ones -->
- Understanding and debugging <!-- using GoLand --> 
- Getting that extra performance kick <!-- profiling, workers, directio, ... -->
- Monitoring and measurements <!-- prometheus -->

.image assets/gophers/GOPHER_ADADEMY.png _ 250

## Why is Go awesome? - the origin story

- Imagine you're working at Google, and seeing the company waste a ton of money every day...

.image assets/xkcd/compiling.png 400 _

- and it's not just compilation !

## The origin story (cont'd)

- C++ is high performance, but cumbersome
- Usability: let's not go there
- Parallelism: only achieved through specialized libraries
- Memory management: manual
- Deployment: dependencies are a pain (DLLs)
- Code formatting: inconsistent across teams
- Maintenance: changing an API in a library is hell if you're Google

## Go as a solution

- High-performance, compiled language inspired by C
- Simple unambiguous syntax, optimized for compilation and human readability
- Statically linked, easy deployment *even across systems*
- Garbage-collected
- Concurrency as a first class-citizen (channels, goroutines)
- Easy to refactor or change APIs: the AST can be manipulated very easily

## Go as a solution (cont'd)

.image assets/free-gophers-pack/characters/png/21.png 400 _

## Go as a solution (cont'd)

- Go is very opinionated
- There's one right way of doing things, incl. code formatting
- Constrains you as a developer, but it saves everyone's time

.image assets/free-gophers-pack/characters/png/28.png 300 _

## Tools you'll love

- go get, go install, go build, go run
- go fmt, goimports
- godoc, go doc
- go vet, staticcheck
- race detection, go test

.image assets/free-gophers-pack/characters/png/59.png 300 _

## go fmt and goimports

- (demo)

## Is my code broken?

- go vet: demo
- staticcheck: demo

## Is my code broken? race detection!

- go run **--race** bad_race.go
- You can use --race with all commands (build, install, run, test)
- (demo)

.image assets/gophers/GOPHER_MIC_DROP.png 300 _

## Testing

- Go comes with unit tests, benchmarks and examples - all built in !
- Consider using library `github.com/stretchr/testify/require`

Examples:
- https://github.com/si-co/vpir-code/blob/main/lib/database/merkle_test.go
- https://github.com/dedis/dela/blob/master/crypto/ed25519/example_test.go

## Other demos

- godoc, go doc

## IDEs
- If you're a Emacs/Vim wizard, keep doing your thing. I'm sure your awesome.
- IDEs ( VSCode, GoLand ) help you be more productive.
- GoLand is particularly powerful, but it requires configuration.
> Editor/Inspections
> Tools/File Watcher
> Tools/External Tools
- We'll come back to IDEs later ;-)

## How to screw up (or not) 

1. Organize your source
1. Handle errors
1. Use custom types

.image assets/free-gophers-pack/illustrations/png/22.png 400 _

## 1: Organize your sources

- (**bad** code + **good** architecture) `>` (**good** code + **bad** architecture)
- break down your project into independent packages
- iterative process (that's an investment, but worth it)
- prevents import cycles
- Avoid general-purpose packages:
    - ‚õîÔ∏è `utils`, ‚õîÔ∏è `types`, ‚õîÔ∏è `data`, ...
    - Break up by topic or dependency
- Define interface for your packages
- üèÜ üèÜ üèÜ 3 wins: readability / testability / maintainability

<center style="padding: 30px">

.link https://github.com/golang-standards/project-layout

</center>

## 1: Organize your sources (cont'd)

<div style="display:flex;justify-content:center;align-items:center; height:100%;font-size:1.6em">

```
server
‚îÇ   mod.go
‚îÇ
‚îî‚îÄ‚îÄ‚îÄstorage          <- standalone functionality
‚îÇ   ‚îÇ   mod.go       <- interface
‚îÇ   ‚îÇ
‚îÇ   ‚îî‚îÄ‚îÄ‚îÄpostgresql   <- an implementation
‚îÇ       ‚îÇ   mod.go
‚îÇ   
‚îî‚îÄ‚îÄ‚îÄotherpackage
    ‚îÇ   ...
```

</div>

## 1: Organize your sources (cont'd)

take an interface, delegate responsibility 

.html pages/organize-your-sources.html

## 2: Handle errors

.image assets/free-gophers-pack/illustrations/png/2.png 250 _

.html pages/errors.html

## If your code doesn't look like this ...

.html pages/errors-handling.html

## Fail fast

.html pages/errors-fail-fast.html

## 3: Embed functionalities with struct

.html pages/embed-struct.html

## 3: Embed functionalities with struct (cont'd)

- not a problem for simple program, but that escalades quickly üî•
- first step to a good architecture
- think of small pieces of functionalities:
    - "I want something to store my routing that is thread-safe"
- extract to a package when this becomes a standalone functionalities

.image assets/gophers/MovingGopher.png 230 _

## Bonus: Channels and routines

- "Do not communicate by sharing memory; instead, share memory by communicating"
    - want to share data between routines ? üëâ channel
- Do not spawn a dynamic number of routines
    - use a pool with workers
- Always have a plan to terminate your routines üî•

## Two problems (at least)

.play goroutines.go

## Better

.play goroutines2.go

## Understanding and debugging

- Printfs everywhere != debugging, let's agree to move past that

.image assets/free-gophers-pack/characters/png/5.png 300 _

- So, what is good debugging?

## Understanding and debugging

- Debugging is a scientific process of discovery
- Part of it is exploratory
- Most of it is the creation and rejection of hypothesis

.image assets/free-gophers-pack/characters/png/49.png 300 _

- What are the tools of inquiry?

## Understanding and debugging: tools

- Logging

  * what is the system doing? sequence and details of operations

- Metrics

  * how is the system performing? # of requests/s, RTT, queue lengths, etc.

- Debugger

  * To look deeper, much much deeper

.image assets/free-gophers-pack/illustrations/png/37.png 300 _

## Let's get down to debugging

- Delve ... maybe not
- GoLand or VSCode

## Optimizing

- You can optimize algorithms ahead of implementing them
- You **can't and shouldn't** optimize code ahead of writing it
- Measure first, act later

<link rel="preconnect" href="https://fonts.gstatic.com">
<link href="https://fonts.googleapis.com/css2?family=Lato:wght@300;400&display=swap" rel="stylesheet"> 

<center style="font-style:normal;font-family:'Lato', sans-serif;font-size:1.2em;color:#888;padding:80px;font-weight:300;letter-spacing:1px;">

‚ÄúThe real problem is that programmers have spent far too much time worrying about efficiency in the wrong places and at the wrong times; <b>premature optimization is the root of all evil</b> (or at least most of it) in programming.‚Äù<br>
<span style="font-size:.7em;padding:20px">-The Art of Computer Programming</span>

</center>

## File IO Optimizations

- The suggestions here don't apply for normal scenarios
- As a rule of thumb, prefer to use io.Reader, io.Writer interfaces - *os.File implements them
- However, there might be scenarios where you want to avoid them

## Recap: Disk IO and Virtual Memory

- Traditional read/write APIs use the read/write syscalls

- Read syscall:
  - Requests the kernel to read the file at an offset
  - If the page is available in the kernel's page cache, the kernel copies it to user space buffer
  - Otherwise we have a page fault, kernel reads the page into page cache and then copies it into user space buffer

- Write syscall:
  - Requests the kernel to copy the data into page cache.
  - Kernel schedules the sync to disk
  - User can block on sync using fsync

## Recap: Disk IO and Virtual Memory
.image assets/io/traditional.svg 700 _

## Memory Mapping

- mmap allows mapping of an entire file in memory
- Process' virtual address space maps directly to page cache
  - No copying of buffers
- Does not imply you need RAM == size of file
  - Because pages are loaded on demand
- Can also map regions of the file in memory
  - Caveat: offset must be page aligned (usually 4K but varies with the system)

## Memory Mapping

- Kernel does have to do more book keeping behind the scenes
- Might be worth it if you're dealing with a large file and want to avoid allocations again and again
- A page fault in mmap doesn't preempt a Go routine
  - you'd underutilise your CPU in that case because an OS thread would be [blocked](https://valyala.medium.com/mmap-in-go-considered-harmful-d92a25cb161d)
- Watchout for concurrent write operations to an mmaped file. `ftruncate` for instance doesn't play well with mmap
  - Have a look at [Bryan Cantrill's experience with tail](https://youtu.be/vm1GJMp0QN4?t=2463)

## Memory Mapping

.html pages/mmap-file-modify.html

## Memory Mapping

.html pages/mmap-fixed-size-data-read.html

## Direct IO

- As the name implies, it allows bypassing the page cache completely!
- Data is copied directly to/from the userspace/disk
- Writes/Reads must be block aligned - usually 512B.
- Useful if you want to control caching on the application level
- Allows finer control over scheduling IO - remember writes just mark a page dirty?
  - the Go runtime and the kernel would still be scheduling your thread

## Direct IO

.html pages/directio-file-copy.html

## File IO Optimisations (summarizing)

- read/write go through page cache and involve copy between kernel/user space
- mmap bypasses the kernel as long as your data is in the page cache
- DirectIO bypasses the page cache completely
- Don't consider the last two as a default - your workload and benchmarks should guide which API to use.