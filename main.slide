# Go for your PhD
The language, its tools, best practices and cool toys
6 May 2021

Gaurav Narula

NoÃ©mien Kocher

Pierluca BorsÃ²


## Talk outline

- Why is Go awesome? <!-- language properties -->
- The tools you're going to love <!-- fmt, vet, race detection, testing tools ... -->
- How to screw up (or not) <!-- bad practices and better ones -->
- Understanding and debugging <!-- using GoLand --> 
- Getting that extra performance kick <!-- profiling, workers, directio, ... -->
- Monitoring and measurements <!-- prometheus -->

.image assets/gophers/GOPHER_ADADEMY.png _ 250

## Next slide

And some more content

## How to screw up (or not) 

- Organize your source
- Handle errors
- Use custom types

.image assets/free-gophers-pack/illustrations/png/22.png 400 _

## Organize your sources

- (**bad** code + **good** architecture) `>` (**good** code + **bad** architecture)
- break down your project into independent packages
- iterative process (that's an investment, but worth it)
- prevents import cycles
- Avoid general-purpose packages:
    - â›”ï¸ `utils`, â›”ï¸ `types`, â›”ï¸ `data`, ...
    - Break up by topic or dependency
- Define interface for your packages
- ğŸ† ğŸ† ğŸ† 3 wins: readability / testability / maintainability

<center style="padding: 30px">

.link https://github.com/golang-standards/project-layout

</center>

## Organize your sources

<div style="display:flex;justify-content:center;align-items:center; height:100%;font-size:1.6em">

```
server
â”‚   mod.go
â”‚
â””â”€â”€â”€storage          <- standalone functionality
â”‚   â”‚   mod.go       <- interface
â”‚   â”‚
â”‚   â””â”€â”€â”€postgresql   <- an implementation
â”‚       â”‚   mod.go
â”‚   
â””â”€â”€â”€otherpackage
    â”‚   ...
```

</div>

## Organize your sources

take an interface, delegate responsibility 

.html pages/organize-your-sources.html

## Handle errors

.image assets/free-gophers-pack/illustrations/png/2.png 250 _

.html pages/errors.html

## If your code doesn't look like this ... ğŸŸ 

.html pages/errors-handling.html

## Fail fast

.html pages/errors-fail-fast.html

## Embed functionalities with struct

.html pages/embed-struct.html

## Embed functionalities with struct

- not a problem for simple program, but that escalades quickly ğŸ”¥
- first step to a good architecture
- think of small pieces of functionalities:
    - "I want something to store my routing that is thread-safe"
- extract to a package when this becomes a standalone functionalities

.image assets/gophers/MovingGopher.png 230 _

## Channels and routines

- "Do not communicate by sharing memory; instead, share memory by communicating"
    - want to share data between routines ? ğŸ‘‰ channel
- Do not spawn a dynamic number of routines
    - use a pool with workers
- Always have a plan to terminate your routines ğŸ”¥

## Two problems (at least)

.play goroutines.go

## Better

.play goroutines2.go
## File Optimisations

- The suggestions here don't apply for normal scenarios
- As a rule of thumb, prefer to use io.Reader, io.Writer interfaces - *os.File implements them
- However, there might be scenarios where you want to avoid them

## Recap: Disk IO and Virtual Memory

- Traditional read/write APIs use the read/write syscalls

- Read syscall:
  - Requests the kernel to read the file at an offset
  - If the page is available in the kernel's page cache, the kernel copies it to user space buffer
  - Otherwise we have a page fault, kernel reads the page into page cache and then copies it into user space buffer

- Write syscall:
  - Requests the kerel to copy the data into page cache.
  - Kernel schedules the sync to disk
  - User can block on sync using fsync

## Recap: Disk IO and Virtual Memory
.image assets/io/traditional.svg 700 _

## Memory Mapping

- mmap allows mapping of an entire file in memory
- Process' virtual address space maps directly to page cache
  - No copying of buffers
- Does not imply you need RAM == size of file
  - Because pages are loaded on demand
- Can also map regions of the file in memory
  - Caveat: offset must be page aligned (usually 4K but varies with the system)

## Memory Mapping

- Kernel does have to do more book keeping behind the scenes
- Might be worth it if you're dealing with a large file and want to avoid allocations again and again
- A page fault in mmap doesn't preempt a Go routine
  - you'd underutilise your CPU in that case because an OS thread would be [blocked](https://valyala.medium.com/mmap-in-go-considered-harmful-d92a25cb161d)
- Watchout for concurrent write operations to an mmaped file. `ftruncate` for instance doesn't play well with mmap
  - Have a look at [Bryan Cantrill's experience with tail](https://youtu.be/vm1GJMp0QN4?t=2463)

## Memory Mapping

.html pages/mmap-file-modify.html

## Memory Mapping

.html pages/mmap-fixed-size-data-read.html

## Direct IO

- As the name implies, it allows bypassing the page cache completely!
- Data is copied directly to/from the userspace/disk
- Writes/Reads must be block aligned - usually 512B.
- Useful if you want to control caching on the application level
- Allows finer control over scheduling IO - remember writes just mark a page dirty?
  - the Go runtime and the kernel would still be scheduling your thread

## Direct IO

.html pages/directio-file-copy.html
